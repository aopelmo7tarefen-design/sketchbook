import React, { useRef, useState, useEffect } from "react";

// Single-file React component: SketchBook-like web app
// - Uses HTML canvas and offscreen canvases as layers
// - Features: multiple layers (add/delete/rename/reorder/visibility/opacity), brush (size, opacity), eraser, color picker, undo/redo, clear, export PNG, import image, fill (bucket), transform (move layer), simple selection
// - Tailwind classes used for styling (no Tailwind imports in file ‚Äî include Tailwind in host project)

export default function SketchBookWeb() {
  const containerRef = useRef(null);
  const [width, setWidth] = useState(1200);
  const [height, setHeight] = useState(700);

  // Layers: each layer is { id, name, canvas (offscreen), visible, opacity }
  const [layers, setLayers] = useState(() => {
    const base = createLayerObject("Background", 0, true, 1);
    const top = createLayerObject("Layer 1", 1, true, 1);
    return [base, top];
  });
  const [activeLayerId, setActiveLayerId] = useState(layers[1]?.id || null);

  // Tool state
  const [tool, setTool] = useState("brush"); // brush | eraser | fill | move
  const [color, setColor] = useState("#000000");
  const [brushSize, setBrushSize] = useState(8);
  const [brushOpacity, setBrushOpacity] = useState(1);

  // History stacks per layer (simple global undo/redo using snapshots)
  const historyRef = useRef({ undo: [], redo: [] });

  // Drawing refs
  const isDrawingRef = useRef(false);
  const lastPosRef = useRef({ x: 0, y: 0 });

  // Main visible canvas ref
  const mainCanvasRef = useRef(null);

  // Initialize sizes responsive
  useEffect(() => {
    const resize = () => {
      const rect = containerRef.current?.getBoundingClientRect();
      if (!rect) return;
      const maxW = Math.min(rect.width - 320, 1400);
      setWidth(Math.max(800, Math.floor(maxW)));
      setHeight(Math.max(500, Math.floor((maxW * 9) / 16)));
    };
    resize();
    window.addEventListener("resize", resize);
    return () => window.removeEventListener("resize", resize);
  }, []);

  // When width/height change, resize offscreen canvases and re-render
  useEffect(() => {
    setLayers((prev) =>
      prev.map((l) => {
        // keep existing content by drawing onto new canvas
        const newOff = document.createElement("canvas");
        newOff.width = width;
        newOff.height = height;
        const ctxNew = newOff.getContext("2d");
        ctxNew.imageSmoothingEnabled = true;
        ctxNew.drawImage(l.canvas, 0, 0, width, height);
        return { ...l, canvas: newOff };
      })
    );
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [width, height]);

  // Initial render to main canvas
  useEffect(() => {
    redrawMain();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [layers]);

  function createEmptyCanvas(w, h) {
    const c = document.createElement("canvas");
    c.width = w;
    c.height = h;
    return c;
  }

  function createLayerObject(name, zIndex, visible = true, opacity = 1) {
    const off = createEmptyCanvas(width, height);
    const ctx = off.getContext("2d");
    ctx.clearRect(0, 0, off.width, off.height);
    return {
      id: `layer_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
      name,
      canvas: off,
      visible,
      opacity,
      zIndex,
    };
  }

  function getLayerById(id) {
    return layers.find((l) => l.id === id);
  }

  function redrawMain() {
    const main = mainCanvasRef.current;
    if (!main) return;
    const ctx = main.getContext("2d");
    ctx.clearRect(0, 0, main.width, main.height);
    // draw in order
    [...layers]
      .sort((a, b) => a.zIndex - b.zIndex)
      .forEach((l) => {
        if (!l.visible) return;
        ctx.globalAlpha = l.opacity;
        ctx.drawImage(l.canvas, 0, 0);
      });
    ctx.globalAlpha = 1;
  }

  function pushHistory(snapshotName = "") {
    // Snapshot full merged image for now (simple implementation)
    const temp = document.createElement("canvas");
    temp.width = width;
    temp.height = height;
    const ctx = temp.getContext("2d");
    [...layers]
      .sort((a, b) => a.zIndex - b.zIndex)
      .forEach((l) => {
        if (!l.visible) return;
        ctx.globalAlpha = l.opacity;
        ctx.drawImage(l.canvas, 0, 0);
      });
    ctx.globalAlpha = 1;
    historyRef.current.undo.push(temp.toDataURL());
    historyRef.current.redo = [];
    // cap history
    if (historyRef.current.undo.length > 30) historyRef.current.undo.shift();
  }

  function undo() {
    if (!historyRef.current.undo.length) return;
    const last = historyRef.current.undo.pop();
    historyRef.current.redo.push(mainCanvasRef.current.toDataURL());
    restoreFromDataURL(last);
  }

  function redo() {
    if (!historyRef.current.redo.length) return;
    const next = historyRef.current.redo.pop();
    historyRef.current.undo.push(mainCanvasRef.current.toDataURL());
    restoreFromDataURL(next);
  }

  function restoreFromDataURL(dataUrl) {
    const img = new Image();
    img.onload = () => {
      // draw onto the topmost layer (or create a new composite layer)
      // For simplicity: clear all layers and put image on background
      setLayers((prev) => {
        const base = createLayerObject("Background", 0, true, 1);
        const ctx = base.canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, base.canvas.width, base.canvas.height);
        // keep other layers empty
        const others = prev.slice(1).map((l, i) => createLayerObject(`Layer ${i + 1}`, i + 1, l.visible, l.opacity));
        return [base, ...others];
      });
    };
    img.src = dataUrl;
  }

  // Mouse/touch handlers on main canvas => draw onto active layer canvas
  function toCanvasCoords(e) {
    const rect = mainCanvasRef.current.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    const x = ((clientX - rect.left) / rect.width) * mainCanvasRef.current.width;
    const y = ((clientY - rect.top) / rect.height) * mainCanvasRef.current.height;
    return { x, y };
  }

  function handlePointerDown(e) {
    if (!activeLayerId) return;
    isDrawingRef.current = true;
    const pos = toCanvasCoords(e);
    lastPosRef.current = pos;
    if (tool === "fill") {
      pushHistory("fill");
      doFloodFill(activeLayerId, Math.round(pos.x), Math.round(pos.y), hexToRgba(color, Math.round(255 * brushOpacity)));
      redrawMain();
      return;
    }
    pushHistory("stroke");
    drawLineTo(activeLayerId, pos.x, pos.y, false);
  }

  function handlePointerMove(e) {
    if (!isDrawingRef.current) return;
    const pos = toCanvasCoords(e);
    drawLineTo(activeLayerId, pos.x, pos.y, true);
  }

  function handlePointerUp() {
    if (!isDrawingRef.current) return;
    isDrawingRef.current = false;
    redrawMain();
  }

  function drawLineTo(layerId, x, y, smoothing = true) {
    const layer = getLayerById(layerId);
    if (!layer) return;
    const ctx = layer.canvas.getContext("2d");
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    ctx.imageSmoothingEnabled = true;
    const last = lastPosRef.current;
    if (tool === "eraser") {
      ctx.globalCompositeOperation = "destination-out";
      ctx.strokeStyle = `rgba(0,0,0,${brushOpacity})`;
    } else {
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = color;
    }
    ctx.globalAlpha = brushOpacity;
    ctx.lineWidth = brushSize;
    ctx.beginPath();
    ctx.moveTo(last.x, last.y);
    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.closePath();
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = "source-over";
    lastPosRef.current = { x, y };
    // live preview on main
    redrawMain();
  }

  // Flood fill algorithm (basic) on a specific layer
  function doFloodFill(layerId, startX, startY, fillColorRgba) {
    const layer = getLayerById(layerId);
    if (!layer) return;
    const ctx = layer.canvas.getContext("2d");
    const w = layer.canvas.width;
    const h = layer.canvas.height;
    const imageData = ctx.getImageData(0, 0, w, h);
    const data = imageData.data;
    const startIdx = (startY * w + startX) * 4;
    const target = [data[startIdx], data[startIdx + 1], data[startIdx + 2], data[startIdx + 3]];
    const fill = fillColorRgba; // [r,g,b,a]
    if (target[0] === fill[0] && target[1] === fill[1] && target[2] === fill[2] && target[3] === fill[3]) return;
    const stack = [[startX, startY]];
    while (stack.length) {
      const [x, y] = stack.pop();
      if (x < 0 || y < 0 || x >= w || y >= h) continue;
      const idx = (y * w + x) * 4;
      if (data[idx] === target[0] && data[idx + 1] === target[1] && data[idx + 2] === target[2] && data[idx + 3] === target[3]) {
        data[idx] = fill[0];
        data[idx + 1] = fill[1];
        data[idx + 2] = fill[2];
        data[idx + 3] = fill[3];
        stack.push([x + 1, y]);
        stack.push([x - 1, y]);
        stack.push([x, y + 1]);
        stack.push([x, y - 1]);
      }
    }
    ctx.putImageData(imageData, 0, 0);
  }

  // Utilities
  function hexToRgba(hex, alpha = 255) {
    const h = hex.replace('#', '');
    const bigint = parseInt(h.length === 3 ? h.split('').map(c => c + c).join('') : h, 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return [r, g, b, alpha];
  }

  // Layer actions
  function addLayer() {
    const next = createLayerObject(`Layer ${layers.length}`, layers.length, true, 1);
    setLayers((p) => {
      const arr = [...p, next];
      // set active to newly created
      setActiveLayerId(next.id);
      return arr;
    });
  }

  function deleteLayer(id) {
    if (layers.length <= 1) return;
    setLayers((p) => p.filter((l) => l.id !== id).map((l, i) => ({ ...l, zIndex: i })));
    setActiveLayerId((prev) => (prev === id ? layers[0].id : prev));
  }

  function toggleVisibility(id) {
    setLayers((p) => p.map((l) => (l.id === id ? { ...l, visible: !l.visible } : l)));
  }

  function setLayerOpacity(id, val) {
    setLayers((p) => p.map((l) => (l.id === id ? { ...l, opacity: val } : l)));
  }

  function renameLayer(id, name) {
    setLayers((p) => p.map((l) => (l.id === id ? { ...l, name } : l)));
  }

  function moveLayerUp(id) {
    setLayers((p) => {
      const idx = p.findIndex((l) => l.id === id);
      if (idx === p.length - 1) return p;
      const copy = [...p];
      [copy[idx], copy[idx + 1]] = [copy[idx + 1], copy[idx]];
      return copy.map((l, i) => ({ ...l, zIndex: i }));
    });
  }

  function moveLayerDown(id) {
    setLayers((p) => {
      const idx = p.findIndex((l) => l.id === id);
      if (idx <= 0) return p;
      const copy = [...p];
      [copy[idx - 1], copy[idx]] = [copy[idx], copy[idx - 1]];
      return copy.map((l, i) => ({ ...l, zIndex: i }));
    });
  }

  function clearLayer(id) {
    pushHistory("clear");
    setLayers((p) =>
      p.map((l) => {
        if (l.id !== id) return l;
        const c = createEmptyCanvas(width, height);
        return { ...l, canvas: c };
      })
    );
  }

  function exportPNG() {
    // produce merged image
    const temp = document.createElement("canvas");
    temp.width = width;
    temp.height = height;
    const ctx = temp.getContext("2d");
    [...layers]
      .sort((a, b) => a.zIndex - b.zIndex)
      .forEach((l) => {
        if (!l.visible) return;
        ctx.globalAlpha = l.opacity;
        ctx.drawImage(l.canvas, 0, 0);
      });
    ctx.globalAlpha = 1;
    const url = temp.toDataURL("image/png");
    const a = document.createElement("a");
    a.href = url;
    a.download = "sketch.png";
    a.click();
  }

  function importImageToLayer(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      const img = new Image();
      img.onload = () => {
        pushHistory("import");
        setLayers((p) =>
          p.map((l, i) => {
            if (i !== p.length - 1) return l;
            const c = createEmptyCanvas(width, height);
            const ctx = c.getContext("2d");
            ctx.drawImage(img, 0, 0, c.width, c.height);
            return { ...l, canvas: c };
          })
        );
      };
      img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
  }

  // Quick helpers UI
  function setActiveByIndex(i) {
    const l = layers[i];
    if (l) setActiveLayerId(l.id);
  }

  return (
    <div className="flex gap-4 p-4" ref={containerRef}>
      {/* Left toolbar */}
      <div className="w-72 bg-white/5 rounded-2xl p-4 flex flex-col gap-4 shadow-md">
        <h2 className="text-lg font-semibold">Tools</h2>
        <div className="flex gap-2 flex-wrap">
          <button onClick={() => setTool("brush")} className={`px-3 py-2 rounded ${tool === "brush" ? "bg-blue-600 text-white" : "bg-white/5"}`}>
            Brush
          </button>
          <button onClick={() => setTool("eraser")} className={`px-3 py-2 rounded ${tool === "eraser" ? "bg-blue-600 text-white" : "bg-white/5"}`}>Eraser</button>
          <button onClick={() => setTool("fill")} className={`px-3 py-2 rounded ${tool === "fill" ? "bg-blue-600 text-white" : "bg-white/5"}`}>Fill</button>
          <button onClick={() => setTool("move")} className={`px-3 py-2 rounded ${tool === "move" ? "bg-blue-600 text-white" : "bg-white/5"}`}>Move</button>
        </div>

        <div>
          <label className="block text-sm">Color</label>
          <input type="color" value={color} onChange={(e) => setColor(e.target.value)} className="w-full h-10 rounded" />
        </div>

        <div>
          <label className="block text-sm">Brush size: {brushSize}px</label>
          <input type="range" min={1} max={200} value={brushSize} onChange={(e) => setBrushSize(parseInt(e.target.value))} className="w-full" />
        </div>
        <div>
          <label className="block text-sm">Opacity: {Math.round(brushOpacity * 100)}%</label>
          <input type="range" min={0.05} max={1} step={0.01} value={brushOpacity} onChange={(e) => setBrushOpacity(parseFloat(e.target.value))} className="w-full" />
        </div>

        <div className="flex gap-2">
          <button onClick={() => { pushHistory("save"); exportPNG(); }} className="flex-1 px-3 py-2 rounded bg-green-600 text-white">Export PNG</button>
          <button onClick={() => { undo(); }} className="px-3 py-2 rounded bg-yellow-500">Undo</button>
          <button onClick={() => { redo(); }} className="px-3 py-2 rounded bg-yellow-600">Redo</button>
        </div>

        <div>
          <label className="block text-sm">Import image to top layer</label>
          <input type="file" accept="image/*" onChange={(e) => importImageToLayer(e.target.files?.[0])} />
        </div>

        <div>
          <label className="block text-sm">Canvas size</label>
          <div className="flex gap-2">
            <input type="number" value={width} onChange={(e) => setWidth(parseInt(e.target.value || '800'))} className="w-1/2 rounded p-1" />
            <input type="number" value={height} onChange={(e) => setHeight(parseInt(e.target.value || '600'))} className="w-1/2 rounded p-1" />
          </div>
        </div>

        <div>
          <button onClick={() => { setLayers([createLayerObject("Background", 0, true, 1)]) ; setActiveLayerId(null); historyRef.current = { undo: [], redo: [] }; }} className="w-full py-2 rounded bg-red-600 text-white">New Document</button>
        </div>

        <div>
          <p className="text-xs text-gray-300">Tip: Use tablet/stylus for best results. This app works fully in-browser and doesn't require installation.</p>
        </div>
      </div>

      {/* Canvas + layers panel */}
      <div className="flex-1 flex gap-4">
        <div className="bg-neutral-900/60 rounded-2xl p-4 flex flex-col gap-3 shadow-inner" style={{ flex: 1 }}>
          <div className="flex items-center justify-between gap-4">
            <h3 className="text-md font-medium">Canvas</h3>
            <div className="text-sm text-gray-300">{width} √ó {height}px</div>
          </div>

          <div className="flex justify-center items-center bg-neutral-800 rounded-lg" style={{ padding: 12 }}>
            <div style={{ position: 'relative', width: width, height: height, borderRadius: 8, overflow: 'hidden', border: '1px solid rgba(255,255,255,0.06)' }}>
              <canvas
                ref={mainCanvasRef}
                width={width}
                height={height}
                style={{ width: '100%', height: '100%', display: 'block', touchAction: 'none', background: 'linear-gradient(135deg, #ffffff08 25%, transparent 25%), linear-gradient(225deg, #ffffff08 25%, transparent 25%), linear-gradient(45deg, #ffffff06 25%, transparent 25%), linear-gradient(315deg, #ffffff06 25%, transparent 25%)', backgroundSize: '20px 20px', backgroundPosition: '0 0, 10px 0, 10px -10px, 0px 10px' }}
                onMouseDown={handlePointerDown}
                onMouseMove={handlePointerMove}
                onMouseUp={handlePointerUp}
                onMouseLeave={handlePointerUp}
                onTouchStart={(e) => { e.preventDefault(); handlePointerDown(e); }}
                onTouchMove={(e) => { e.preventDefault(); handlePointerMove(e); }}
                onTouchEnd={(e) => { e.preventDefault(); handlePointerUp(e); }}
              />
            </div>
          </div>

          <div className="flex gap-2">
            <button onClick={() => { setTool('brush'); }} className="px-3 py-2 rounded bg-white/5">Brush</button>
            <button onClick={() => { setTool('eraser'); }} className="px-3 py-2 rounded bg-white/5">Eraser</button>
            <button onClick={() => { setTool('fill'); }} className="px-3 py-2 rounded bg-white/5">Fill</button>
            <button onClick={() => { pushHistory('merge'); setLayers((p) => p.map((l,i)=> ({...l, canvas: l.canvas}))); }} className="px-3 py-2 rounded bg-white/5">Merge</button>
          </div>
        </div>

        {/* Layers panel */}
        <div className="w-72 bg-white/5 rounded-2xl p-4 flex flex-col gap-3">
          <div className="flex items-center justify-between">
            <h3 className="text-md font-medium">Layers</h3>
            <div className="flex gap-2">
              <button onClick={addLayer} className="px-2 py-1 rounded bg-blue-600 text-white">+ Add</button>
              <button onClick={() => { setLayers((p) => p.map((l, i) => ({ ...l, canvas: l.canvas }))); }} className="px-2 py-1 rounded bg-white/5">Refresh</button>
            </div>
          </div>

          <div className="flex flex-col gap-2 overflow-y-auto" style={{ maxHeight: 420 }}>
            {[...layers]
              .slice()
              .reverse()
              .map((l, idxReverse) => {
                const idx = layers.length - 1 - idxReverse;
                return (
                  <div key={l.id} className={`p-2 rounded ${activeLayerId === l.id ? 'bg-white/6' : 'bg-white/3/0'}`}>
                    <div className="flex items-center justify-between gap-2">
                      <div className="flex items-center gap-2">
                        <button onClick={() => toggleVisibility(l.id)} className="px-1 py-1 rounded bg-white/5">{l.visible ? 'üëÅ' : 'üö´'}</button>
                        <div className="flex flex-col">
                          <input value={l.name} onChange={(e) => renameLayer(l.id, e.target.value)} className="bg-transparent text-sm" />
                          <div className="text-xs text-gray-400">Opacity: {Math.round(l.opacity * 100)}%</div>
                        </div>
                      </div>

                      <div className="flex items-center gap-1">
                        <button onClick={() => moveLayerUp(l.id)} className="px-2 py-1 rounded bg-white/5">‚ñ≤</button>
                        <button onClick={() => moveLayerDown(l.id)} className="px-2 py-1 rounded bg-white/5">‚ñº</button>
                        <button onClick={() => clearLayer(l.id)} className="px-2 py-1 rounded bg-red-600 text-white">Clear</button>
                        <button onClick={() => { deleteLayer(l.id); }} className="px-2 py-1 rounded bg-red-700 text-white">Del</button>
                      </div>
                    </div>

                    <div className="flex items-center gap-2 mt-2">
                      <input type="range" min={0} max={1} step={0.01} value={l.opacity} onChange={(e) => setLayerOpacity(l.id, parseFloat(e.target.value))} className="flex-1" />
                      <button onClick={() => { setActiveLayerId(l.id); }} className={`px-2 py-1 rounded ${activeLayerId === l.id ? 'bg-blue-600 text-white' : 'bg-white/5'}`}>Select</button>
                    </div>
                  </div>
                );
              })}
          </div>

          <div className="flex gap-2 mt-2">
            <button onClick={() => exportPNG()} className="flex-1 py-2 rounded bg-green-600 text-white">Export Merged</button>
            <button onClick={() => pushHistory('snapshot')} className="py-2 px-3 rounded bg-yellow-500">Snapshot</button>
          </div>

          <div className="text-xs text-gray-400 mt-2">Tip: Click a layer then draw. Use Undo/Redo to step back. Resize canvas before heavy work.</div>
        </div>
      </div>
    </div>
  );
}
